<!--
  Virtual Dive – HNLMS K XI (1946)
  -------------------------------------------------------
  • Desktop/phone: Orbit drag & scroll.
  • Quest 2 VR   : Thumbsticks to fly/turn.
  • Even lighting; KTX2, Draco & Meshopt decoding wired.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Virtual Dive – HNLMS K XI</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#111;color:#eee;font-family:sans-serif}
  #info{position:absolute;top:10px;left:10px;z-index:10;background:rgba(0,0,0,.55);padding:6px 10px;border-radius:6px;font-size:13px;line-height:1.3em}
  a{color:#87cefa;text-decoration:none}
</style>
<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js"}}</script>
</head>
<body>
<div id="info">
  <strong>VR:</strong> Left stick: move | Right stick: turn/fly | Y: measure toggle<br>
  <strong>Desktop:</strong> Drag: orbit | Scroll: zoom | Double-click: focus | M: measure
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader }  from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/loaders/DRACOLoader.js';
import { KTX2Loader }  from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/loaders/KTX2Loader.js';
import { MeshoptDecoder } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/libs/meshopt_decoder.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/XRControllerModelFactory.js';

// Import the Line2 materials for thick lines
import { Line2 } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/lines/Line2.js';
import { LineMaterial } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/lines/LineMaterial.js';
import { LineGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/lines/LineGeometry.js';

// ------------------------ Config ----------------------------
const MODEL_URL  = 'models/kxi.glb';   // your optimised K XI model (Basis‑KTX2 + Draco)
const MOVE_SPEED = 2.0;    // m/s base movement speed
const TURN_SPEED = 1.5;    // rad/s turn speed
const FLY_SPEED = 1.0;     // m/s vertical movement
const TELEPORT_DISTANCE = 5.0; // max teleport distance
//-------------------------------------------------------------

// Scene basics
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a1a2a); // Deeper ocean blue

const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.05, 2000);
const dolly  = new THREE.Group(); dolly.add(camera); scene.add(dolly);

const renderer = new THREE.WebGLRenderer({antialias:true,powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5));
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.xr.enabled = true;

document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

// Desktop orbit controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; 
controls.dampingFactor = 0.08;
controls.maxDistance = 100;
controls.minDistance = 0.5;

// Cancel focus animation when user manually controls camera
controls.addEventListener('start', () => {
  if (focusAnimation) {
    cancelAnimationFrame(focusAnimation);
    focusAnimation = null;
  }
});

// Movement state
const moveState = {
  isMoving: false,
  buttonPressed: false,
  moveVector: new THREE.Vector3(),
  rotationTarget: 0,
  currentRotation: 0
};

// Raycaster for interactions
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Controller tracking spheres - make twice as big
const sphereGeometry = new THREE.SphereGeometry(0.02, 8, 6); // 4cm radius, low-poly
const ghostMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.2});
const placedMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});

// Maximum of 2 placed spheres
const MAX_SPHERES = 2;
const placedSpheres = [];
const ghostSpheres = {
  left: new THREE.Mesh(sphereGeometry, ghostMaterial),
  right: new THREE.Mesh(sphereGeometry, ghostMaterial)
};

// Add line between spheres - make it show through objects
let connectionLine = null;
const lineMaterial = new THREE.LineBasicMaterial({ 
  color: 0xffffff, 
  transparent: true, 
  opacity: 0.5,
  linewidth: .1,
  depthTest: false // This makes the line render on top of everything
});

// Replace the VR line material with proper initialization
const vrLineMaterial = new LineMaterial({
  color: 0xffffff,
  linewidth: 3,
  transparent: true,
  opacity: 0.8,
  depthTest: false,
  vertexColors: false,
  dashed: false,
  resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) // Add this
});

// Replace the desktop line material with proper initialization  
const desktopLineMaterial = new LineMaterial({
  color: 0xffffff,
  linewidth: 3,
  transparent: true,
  opacity: 0.8,
  depthTest: false,
  vertexColors: false,
  dashed: false,
  resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) // Add this
});

// Add ghost spheres to scene
ghostSpheres.left.visible = false;
ghostSpheres.right.visible = false;
scene.add(ghostSpheres.left);
scene.add(ghostSpheres.right);

// Double-click focus system
let lastClickTime = 0;
const DOUBLE_CLICK_TIME = 300;
let focusAnimation = null; // Track ongoing animation

window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

// Mouse/touch interaction
renderer.domElement.addEventListener('click', onMouseClick);

// Add these variables near the top with other declarations
let isDragging = false;
let dragStartPosition = { x: 0, y: 0 };
const DRAG_THRESHOLD = 5; // pixels

// Add mouse event listeners for drag detection
renderer.domElement.addEventListener('mousedown', onMouseDown);
renderer.domElement.addEventListener('mousemove', onMouseMove);
renderer.domElement.addEventListener('mouseup', onMouseUp);

function onMouseDown(event) {
  isDragging = false;
  dragStartPosition.x = event.clientX;
  dragStartPosition.y = event.clientY;
}

function onMouseMove(event) {
  if (!isDragging) {
    const deltaX = Math.abs(event.clientX - dragStartPosition.x);
    const deltaY = Math.abs(event.clientY - dragStartPosition.y);
    
    if (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) {
      isDragging = true;
    }
  }
}

function onMouseUp(event) {
  // Reset drag state after a short delay to allow click event to process
  setTimeout(() => {
    isDragging = false;
  }, 10);
}

// Update the onMouseClick function to check for dragging
function onMouseClick(event) {
  const currentTime = Date.now();
  const isDoubleClick = currentTime - lastClickTime < DOUBLE_CLICK_TIME;
  lastClickTime = currentTime;
  
  if (renderer.xr.isPresenting || isDragging) return; // Don't place spheres when dragging
  
  // Calculate mouse position
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  // Raycast from camera
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(scene.children, true);
  
  if (intersects.length > 0) {
    // Filter out measurement spheres and lines from intersections
    const validIntersects = intersects.filter(intersect => 
      !desktopMeasurementPoints.includes(intersect.object) &&
      intersect.object !== desktopMeasurementLine &&
      intersect.object !== connectionLine &&
      !placedSpheres.includes(intersect.object)
    );
    
    if (validIntersects.length > 0) {
      if (isDoubleClick) {
        // Double-click: focus on point
        focusOnPoint(validIntersects[0].point);
      } else if (desktopMeasurementMode) {
        // Single click: place measurement point (only if measurement mode is active and not dragging)
        const intersectionPoint = validIntersects[0].point;
        
        // If we already have max points, remove the oldest one
        if (desktopMeasurementPoints.length >= MAX_DESKTOP_POINTS) {
          const oldestSphere = desktopMeasurementPoints.shift();
          scene.remove(oldestSphere);
        }
        
        // Create new measurement sphere using VR style (white spheres)
        const measurementSphere = new THREE.Mesh(sphereGeometry, placedMaterial);
        measurementSphere.position.copy(intersectionPoint);
        scene.add(measurementSphere);
        desktopMeasurementPoints.push(measurementSphere);
        
        updateDesktopMeasurement();
      }
    }
  }
}

function focusOnPoint(point) {
  // Cancel any existing focus animation
  if (focusAnimation) {
    cancelAnimationFrame(focusAnimation);
    focusAnimation = null;
  }
  
  const startTarget = controls.target.clone();
  const startPosition = camera.position.clone();
  
  // Calculate new camera position (maintain relative offset)
  const offset = startPosition.clone().sub(startTarget);
  const newPosition = point.clone().add(offset);
  
  // Smooth animation
  const duration = 1000; // 1 second
  const startTime = performance.now();
  
  function animate() {
    const elapsed = performance.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3); // ease-out cubic
    
    controls.target.lerpVectors(startTarget, point, eased);
    camera.position.lerpVectors(startPosition, newPosition, eased);
    
    if (progress < 1) {
      focusAnimation = requestAnimationFrame(animate);
    } else {
      focusAnimation = null; // Animation complete
    }
  }
  
  focusAnimation = requestAnimationFrame(animate);
}

// Enhanced lighting for underwater feel
scene.add(new THREE.AmbientLight(0x404080, 0.6));
scene.add(new THREE.HemisphereLight(0x4080ff, 0x002040, 0.4));

// Add subtle directional light from above
const sunlight = new THREE.DirectionalLight(0x8099ff, 0.5);
sunlight.position.set(0, 100, 0);
scene.add(sunlight);

// Loaders setup
const draco = new DRACOLoader().setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/libs/draco/');
const ktx2  = new KTX2Loader().setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/libs/basis/').detectSupport(renderer);

const loader = new GLTFLoader();
loader.setDRACOLoader(draco);
loader.setKTX2Loader(ktx2);
loader.setMeshoptDecoder(MeshoptDecoder);

// Load the wreck
let wreck=null;
loader.load(MODEL_URL, gltf => {
  wreck = gltf.scene; scene.add(wreck);
  const box = new THREE.Box3().setFromObject(wreck);
  const sz  = box.getSize(new THREE.Vector3()).length();
  const ctr = box.getCenter(new THREE.Vector3());
  wreck.position.sub(ctr); // centre
  controls.target.set(0,0,0);
  camera.position.set(0, sz*0.3, sz*0.8);
}, undefined, err => console.error(err));

// Add these variables after the existing sphere and line declarations
let measurementSprite = null;
let measurementCanvas = null;
let measurementTexture = null;

// Add measurement system state variable after the existing sphere declarations
let measurementSystemEnabled = true; // Start enabled
let yButtonPressed = false; // Track Y button state
let bButtonPressed = false; // Track B button state
let desktopMeasurementMode = false; // Desktop measurement mode toggle

// Function to create measurement display
function createMeasurementDisplay(distance) {
  // Create canvas for text
  if (!measurementCanvas) {
    measurementCanvas = document.createElement('canvas');
    measurementCanvas.width = 256;
    measurementCanvas.height = 64;
  }
  
  const context = measurementCanvas.getContext('2d');
  context.clearRect(0, 0, measurementCanvas.width, measurementCanvas.height);
  
  // Measure text to get proper background size
  context.font = '600 24px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif';
  const text = `${distance.toFixed(2)}m`;
  const textMetrics = context.measureText(text);
  const textWidth = textMetrics.width;
  const textHeight = 24; // Font size
  
  // Add padding
  const padding = 8;
  const bgWidth = textWidth + (padding * 2);
  const bgHeight = textHeight + (padding * 2);
  
  // Calculate position to center the background
  const bgX = (measurementCanvas.width - bgWidth) / 2;
  const bgY = (measurementCanvas.height - bgHeight) / 2;
  
  // Draw background with rounded corners
  context.fillStyle = 'rgba(0, 0, 0, 0.8)';
  context.beginPath();
  context.roundRect(bgX, bgY, bgWidth, bgHeight, 4);
  context.fill();
  
  // Draw text centered
  context.fillStyle = 'white';
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.fillText(text, measurementCanvas.width / 2, measurementCanvas.height / 2);
  
  // Create or update texture
  if (!measurementTexture) {
    measurementTexture = new THREE.CanvasTexture(measurementCanvas);
  } else {
    measurementTexture.needsUpdate = true;
  }
  
  // Create or update sprite
  if (!measurementSprite) {
    const spriteMaterial = new THREE.SpriteMaterial({ map: measurementTexture });
    measurementSprite = new THREE.Sprite(spriteMaterial);
    measurementSprite.scale.set(0.3, 0.075, 1); // Scale down the sprite
  }
  
  return measurementSprite;
}

// Remove the immediate controller initialization (lines around 290-310)
// Replace with this VR session event handling:

// Initialize controllers when VR session starts
let controller1, controller2, controllerGrip1, controllerGrip2;
let controllerModel1, controllerModel2;
let controllersInitialized = false;

// Enhanced console warning suppression for VR controller models
let originalConsoleWarn = null;

function suppressControllerWarnings() {
  if (originalConsoleWarn) return; // Already suppressed
  
  originalConsoleWarn = console.warn;
  console.warn = function(message, ...args) {
    // Suppress specific VR controller model warnings
    if (typeof message === 'string' && (
      message.includes('Could not find') && message.includes('in the model') ||
      message.includes('menu_pressed_min') ||
      message.includes('XRControllerModelFactory')
    )) {
      return; // Suppress these warnings
    }
    originalConsoleWarn.apply(console, [message, ...args]);
  };
}

function restoreConsoleWarn() {
  if (originalConsoleWarn) {
    console.warn = originalConsoleWarn;
    originalConsoleWarn = null;
  }
}

function initializeVRControllers() {
  if (controllersInitialized) return;

  try {
    // Start suppressing warnings before any controller operations
    suppressControllerWarnings();
    
    const controllerModelFactory = new XRControllerModelFactory();

    controller1 = renderer.xr.getController(0);
    controller2 = renderer.xr.getController(1);
    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip2 = renderer.xr.getControllerGrip(1);

    if (controller1) dolly.add(controller1);
    if (controller2) dolly.add(controller2);
    if (controllerGrip1) dolly.add(controllerGrip1);
    if (controllerGrip2) dolly.add(controllerGrip2);

    controllerModel1 = controllerModelFactory.createControllerModel(controllerGrip1);
    controllerModel2 = controllerModelFactory.createControllerModel(controllerGrip2);
    if (controllerGrip1) controllerGrip1.add(controllerModel1);
    if (controllerGrip2) controllerGrip2.add(controllerModel2);

    // Attach ghost spheres to controllers
    if (controller1) controller1.add(ghostSpheres.left);
    if (controller2) controller2.add(ghostSpheres.right);

    controllersInitialized = true;
  } catch (error) {
    console.warn('Failed to initialize VR controllers:', error);
  }
  // Note: We keep warning suppression active during VR session
}

renderer.xr.addEventListener('sessionstart', () => {
  initializeVRControllers();
});

renderer.xr.addEventListener('sessionend', () => {
  controllersInitialized = false;
  restoreConsoleWarn(); // Restore normal console warnings when VR ends
});

// Update ghost sphere visibility
function vrMove(dt) {
  const session = renderer.xr.getSession();
  if (!session || !controllersInitialized) return;

  ghostSpheres.left.visible = true;
  ghostSpheres.right.visible = true;

  try {
    // Get input sources and filter for controllers with gamepads
    const inputSources = Array.from(session.inputSources).filter(src => 
      src && src.gamepad && src.handedness && src.gamepad.axes && src.gamepad.buttons
    );

    if (inputSources.length === 0) return;

    let leftController = null;
    let rightController = null;

    // Find controllers by handedness
    for (const src of inputSources) {
      if (src.handedness === 'left') leftController = src;
      if (src.handedness === 'right') rightController = src;
    }

    // Left controller - movement
    if (leftController && leftController.gamepad) {
      const gamepad = leftController.gamepad;
      
      // Quest 2 mapping: axes[2] = x-axis, axes[3] = y-axis for left thumbstick
      const x = (gamepad.axes.length > 2) ? (gamepad.axes[2] || 0) : 0; // strafe
      const y = (gamepad.axes.length > 3) ? (gamepad.axes[3] || 0) : 0; // walk (-y = forward)

      // Only process if we have significant input
      if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
        // Cancel focus animation if user starts moving
        if (focusAnimation) {
          cancelAnimationFrame(focusAnimation);
          focusAnimation = null;
        }

        // Get movement directions relative to camera
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;

        if (forward.lengthSq() < 1e-6) {
          forward.set(0, 0, -1).applyQuaternion(dolly.quaternion);
        } else {
          forward.normalize();
        }

        const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();

        // Speed boost with EITHER controller's grip/squeeze - 5x speed
        const leftGrip = gamepad.buttons[1] && gamepad.buttons[1].pressed;
        const rightGrip = rightController && rightController.gamepad && 
                         rightController.gamepad.buttons[1] && rightController.gamepad.buttons[1].pressed;
        const speedMultiplier = (leftGrip || rightGrip) ? 5 : 1;
        const speed = MOVE_SPEED * speedMultiplier * dt;

        // Horizontal movement
        dolly.position.addScaledVector(forward, -y * speed);
        dolly.position.addScaledVector(right, x * speed);
      }
    }

    // Right controller - turning and flying
    if (rightController && rightController.gamepad) {
      const gamepad = rightController.gamepad;
      
      // Quest 2 mapping: axes[2] = x-axis, axes[3] = y-axis for right thumbstick
      const x = (gamepad.axes.length > 2) ? (gamepad.axes[2] || 0) : 0; // turn
      const y = (gamepad.axes.length > 3) ? (gamepad.axes[3] || 0) : 0; // fly

      // Only process if we have significant input
      if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
        // Cancel focus animation if user starts turning/flying
        if (focusAnimation) {
          cancelAnimationFrame(focusAnimation);
          focusAnimation = null;
        }

        // Speed boost with EITHER controller's grip/squeeze - 5x speed
        const rightGrip = gamepad.buttons[1] && gamepad.buttons[1].pressed;
        const leftGrip = leftController && leftController.gamepad && 
                        leftController.gamepad.buttons[1] && leftController.gamepad.buttons[1].pressed;
        const speedMultiplier = (leftGrip || rightGrip) ? 5 : 1;

        // Smooth turning with right stick X
        if (Math.abs(x) > 0.1) {
          dolly.rotation.y -= x * TURN_SPEED * speedMultiplier * dt;
        }

        // Vertical movement with right stick Y
        if (Math.abs(y) > 0.1) {
          dolly.position.y -= y * FLY_SPEED * speedMultiplier * dt;
        }
      }
    }

    // Handle measurement system buttons
    if (rightController && rightController.gamepad) {
      const gamepad = rightController.gamepad;
      
      // Y button (button[4] on Quest 2) - toggle measurement system
      const yButton = gamepad.buttons[4] && gamepad.buttons[4].pressed;
      if (yButton && !yButtonPressed) {
        measurementSystemEnabled = !measurementSystemEnabled;
        updateMeasurementPanel();
        
        if (!measurementSystemEnabled) {
          // Clear VR measurements
          ghostSpheres.left.visible = false;
          ghostSpheres.right.visible = false;
          placedSpheres.forEach(sphere => scene.remove(sphere));
          placedSpheres.length = 0;
          if (connectionLine) {
            scene.remove(connectionLine);
            connectionLine = null;
          }
          if (measurementSprite) {
            measurementSprite.visible = false;
          }
        }
      }
      yButtonPressed = yButton;

      // Handle trigger for measurement placement
      const trigger = gamepad.buttons[0] && gamepad.buttons[0].pressed;
      if (trigger && measurementSystemEnabled && rightController) {
        // Get controller world position
        const controllerPosition = new THREE.Vector3();
        const rightControllerObj = renderer.xr.getController(1);
        if (rightControllerObj) {
          rightControllerObj.getWorldPosition(controllerPosition);
          
          // Raycast from controller
          const controllerDirection = new THREE.Vector3(0, 0, -1);
          rightControllerObj.getWorldDirection(controllerDirection);
          
          raycaster.set(controllerPosition, controllerDirection);
          const intersects = raycaster.intersectObjects(scene.children, true);
          
          if (intersects.length > 0) {
            const validIntersects = intersects.filter(intersect => 
              !placedSpheres.includes(intersect.object) &&
              intersect.object !== connectionLine &&
              intersect.object !== measurementSprite
            );
            
            if (validIntersects.length > 0) {
              // Place measurement sphere
              if (placedSpheres.length >= MAX_SPHERES) {
                const oldestSphere = placedSpheres.shift();
                scene.remove(oldestSphere);
              }
              
              const measurementSphere = new THREE.Mesh(sphereGeometry, placedMaterial);
              measurementSphere.position.copy(validIntersects[0].point);
              scene.add(measurementSphere);
              placedSpheres.push(measurementSphere);
              
              updateVRMeasurement();
            }
          }
        }
      }
    }

  } catch (error) {
    console.warn('Error in vrMove:', error);
  }
}

// Add VR measurement update function
function updateVRMeasurement() {
  updateMeasurementPanel();
  
  if (placedSpheres.length === 2) {
    // Create or update line with enhanced visibility
    if (connectionLine) {
      scene.remove(connectionLine);
    }
    
    const lineGeometry = new LineGeometry();
    const positions = [];
    positions.push(
      placedSpheres[0].position.x, placedSpheres[0].position.y, placedSpheres[0].position.z,
      placedSpheres[1].position.x, placedSpheres[1].position.y, placedSpheres[1].position.z
    );
    lineGeometry.setPositions(positions);
    
    connectionLine = new Line2(lineGeometry, vrLineMaterial);
    connectionLine.computeLineDistances();
    scene.add(connectionLine);
    
    // Create measurement display
    const distance = placedSpheres[0].position.distanceTo(placedSpheres[1].position);
    const display = createMeasurementDisplay(distance);
    if (display && !scene.children.includes(display)) {
      scene.add(display);
    }
  } else {
    if (connectionLine) {
      scene.remove(connectionLine);
      connectionLine = null;
    }
    if (measurementSprite) {
      measurementSprite.visible = false;
    }
  }
}

// ...existing code...
</script>
</body>
</html>
